---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
library(estudy2)
library(tidyverse)
library(zoo)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.


```{r 2. Market-adjusted-returns model}


rates_indx <- get_prices_from_tickers("^N100",
                                      start = as.Date("2000-01-01"),
                                      end = as.Date("2002-01-01"),
                                      quote = "Close",
                                      retclass = "zoo") %>%
    get_rates_from_prices(quote = "Close",
                          multi_day = TRUE,
                          compounding = "continuous")

tickers <- c("ALV.DE", "CS.PA", "G.MI", "HNR1.HA", "HSX.L", "MUV2.DE",
             "RSA.L", "TOP.CO")

 tasty1 <- get_prices_from_tickers(tickers,
                                              start = as.Date("2000-01-01"),
                                              end = as.Date("2002-01-01"),
                                              quote = "Close",
                                              retclass = "zoo")
    tasty2 <- get_rates_from_prices(tasty1, quote = "Close",
                          multi_day = TRUE,
                          compounding = "continuous")
    securities_returns <- apply_market_model(tasty2, regressor = rates_indx,
                       same_regressor_for_all = TRUE,
                       market_model = "mrkt_adj",
                       estimation_start = as.Date("2001-03-26"),
                       estimation_end = as.Date("2001-09-10"))
```

```{r estudy2_prepare_911}

# Preparing the financial data for use in the 911 test:
estudy2_symbol_returns <- symbol_returns_eventstudies_911

# Pipe to prepare a tibble which contains all of the information needed to calculate the results:
# Take the list with indices for companies
symbol_mcap_911 %>%
  # convert to tibble before piping with Tidyverse "tidying":
  as_tibble() %>%
  # select only the names and indices
  select("name", "index") %>%
  # add additional column with the index for each company
  inner_join(event_dates_911, by = "name") %>%
  # only select securities, dates and indices (data does not need to be rearranged)
  select("name", when, "index") %>%
  # add column with date of end of event window
  mutate(eve_end = when + max(new_days_911)) %>%
  # add column with date of beginning of event window
  mutate(eve_start = when + min(new_days_911)) %>%
  # add column with date of start of estimation window  
  mutate(estim_end = eve_start - 14) %>%
  # add column with date of end of estimation window 
  mutate(estim_start = estim_end - estimation_period_911) ->
  # return result as 
  input_estudy2_911

```



```{r estudy2_nonpara_func}
# Function to calculate the results from the prepared data set
estudy2_car <- function(x, output)
{
  # directly return single security data on row x. no zoo class required.
  estudy2_symbol_returns %>%
  .[, x["name"]] %>%
  # duplicate security data, so that the mean result can be given by doubling and then halving the results. Package estudy2 only functions with average results taken from a nonsingular selection of securities.
  merge(., .) ->
  security_returns_estudy2
  # directly return single index data on row x. no zoo class required.
estudy2_symbol_returns %>%
  .[, x["index"]] ->
  index_returns_estudy2 
# functions from estudy2:
    security_returns_estudy2 %>%
# calculate the alpha and beta values needed for the market model
  estudy2::apply_market_model(regressor = index_returns_estudy2,
                      # this must be true for only one index.
                       same_regressor_for_all = TRUE,
                      # market adjusted takes alpha and beta into account
                       market_model = "sim",
                      # uses ordinary least squares to calculate alpha and beta
                      estimation_method = "ols",
                      # start of estimation period
                       estimation_start = as.Date(x["estim_start"]),
                      # end of estimation period
                       estimation_end = as.Date(x["estim_end"])) %>%
      # function to calculate non-parametric tests, start of observation window
    estudy2::nonparametric_tests(event_start = as.Date(x["eve_start"]),
                    # end of observation window
                     event_end = as.Date(x["eve_end"])) ->
  # returns results from the package to be manipulated
  return_results
    
    
  # preparation so observation period always remains the same size by converting to calendar days:-----
  # fill missing time solutions from Github:
  # https://gist.github.com/ateucher/e2e5bd0b592f3efd6d56  
  # Calculate the actual number of days passed, to determine the event date:
  event_passed_days <- seq(as.Date(inbetween[1,"eve_start"]), 
                           as.Date(inbetween[1,"eve_end"]), 
                           # list all calendar days
                           "day") %>%
  # convert to a data frame to can be merged with another data frame and assigns it to the column "date" (otherwise it is just a vector)
  data.frame(date = .)
  
    
# manipulate results to only those required for plotting before returning outside of function:------
  return_results2 <- return_results %>%
  # only the date and rank according to corrado are required
  select("date","mrank_stat") %>%
  # the actual dates cannot be used because they only take working days and not calendar days into account, so the event would not take place at the same point in the event window any more
  # fill missing time solutions from Github https://gist.github.com/ateucher/e2e5bd0b592f3efd6d56
  # fill missing values (NA) from day sequence of same time period with interpolated values:
  merge(event_passed_days, ., by = "date", all.x = TRUE) %>%
  # NOTE: na.approx() %>% could be used here in the pipe if interpolated values are needed
  # transpose from a vertical list to a horizontal vector
  t %>%
  # select only results, drop the dates, since only vectors can be returned without nesting:
    .[-1, ]
    
    
  # end of function
    }
```


```{r estudy2_nonpara_results}
# combines the rowwise results for individual securies with the original data frame:
  rank_results_estudy2 <- input_estudy2_911 %>%
    # apply function to call estudy2 package rowwise:
    apply(., 1, estudy2_car) %>%
    # transposes results in columns to results in rows
    t %>%
    # converts results to a data frame
    as.data.frame() %>%
    # renames columns accordin to day of observation period
    data.table::setnames(as.character(new_days_911)) %>%
    # converts to a tibble
    as.tibble() %>%
    # convert results from list class to numeric class
    lapply(as.numeric) %>%
    # appends new columns onto the original file
    cbind(input_estudy2_911, .)
    
```


```{r estudy2_nonpara_plot}
# prepares results for plotting:-------
plot_rank_estudy_911 <- rank_results_estudy2 %>%
    # combine the name and when so the results are unique
    unite(when, c("name", "when")) %>%
    # removed unwanted information
    select(when, "-3":"10") %>%
    # rename results
    dplyr::rename("Event.ID" = "when") %>%
    # melt results (gives warning that variables are dropped: this is fine, they are NAs anyway)
    reshape2::melt(id.vars = "Event.ID")

# plots results     
# plot results with ggplot---------------------
print(ggplot(plot_rank_estudy_911, aes(x = variable, y = value))
      + stat_boxplot(fun.data = "mean_cl_boot")
      + geom_line(aes(color = Event.ID, group = Event.ID, size = 0.01))
      + theme(legend.position="none")
      + geom_vline(xintercept = 0)
      + labs(x = "day", y = "rank significance"))
```


```{r function estudy2 test}
# calling the values needed:
# security_e2 <- x["name"]
# market_id <- symbol_mcap[symbol_mcap$name == event_dates[row, "name"], "index"]
# eventdate <- event_dates[row, "when"]
estudy2_car2 <- function(x, output)
{
# select security data from xts data array to single list of dates for security required
  symbol_returns_eventstudies_911 %>%
  .[, inbetween[1,"name"]] %>%
     merge(., .) %>%
  as.zoo() ->
  security_returns_estudy2
  
# select index data from xts data array to single list of dates for index required
symbol_returns_eventstudies_911 %>%
  .[, inbetween[1,"index"]] %>%
  as.zoo() ->
  index_returns_estudy2 


# functions from estudy2:
    security_returns_estudy2 %>%
  estudy2::apply_market_model(regressor = index_returns_estudy2,
                       same_regressor_for_all = TRUE,
                       market_model = "mrkt_adj",
                       estimation_start = as.Date(inbetween[1,"estim_start"]),
                       estimation_end = as.Date(inbetween[1,"estim_end"])) %>%
    estudy2::nonparametric_tests(event_start = as.Date(inbetween[1,"eve_start"]),
                     event_end = as.Date(inbetween[1,"eve_end"])) ->
  return_results
    
  # Calculate the actual number of days passed, to determine the event date:
  event_passed_days <- seq(as.Date(inbetween[1,"eve_start"]), 
                           as.Date(inbetween[1,"eve_end"]), 
                           # list all calendar days
                           "day") %>%
    # convert to a data frame to can be merged with another data frame (otherwise it is just a vector)
    data.frame(date = .)

    
# manipulate results to a row of values:
  return_results2 <- return_results %>%
  # only the date and rank according to corrado are required
  select("date","mrank_stat") %>%
  # fill missing time solutions from Stackoverflow:
  # https://stackoverflow.com/questions/33186316/linear-interpolate-missing-values-in-time-series
  # convert to zoo time series
  #read.zoo %>%
  # fill missing values (NA) from day sequence of same time period with interpolated values:
  merge(event_passed_days, ., by = "date", all.x = TRUE) %>%
  # # covert zoo into data.frame
  # fortify.zoo %>%
  # convert data.frame into tibble
  as_tibble() %>%
  # transpose
  t %>%
  # 
  # colnames(return_results2) <- return_results2[1, ]
  # # make new variable
  # return_results3 <- return_results2 %>%
  # # convert to tibble so column names are retained
  #   as_tibble() %>% 
  # select only results
    .[-1, ]
    
  
  # %>%
  # select("mean") %>%
  # cumsum %>%
  # "*"(100) %>%
  # t
    }

symbol_mcap_911 %>%
  select("name", "index") %>%
  inner_join(event_dates_911, by = "name") %>%
  select("name", "when", "index") %>%
  mutate(eve_end = when + max(new_days_911)) %>%
  mutate(eve_start = when + min(new_days_911)) %>%
  mutate(estim_end = eve_start - 14) %>%
  mutate(estim_start = estim_end - estimation_period_911) ->
  inbetween

  # inbetween %>%
  # mutate(results = apply(., 1, estudy2_car2)) ->
  # events_estudy2

tasty <- estudy2_car2(inbetween)
colnames(tasty) <- 
```


```{r melt 2. Market-adjusted-returns model}
securities_returns %>%
  set_names(c("ALV.DE", "CS.PA", "G.MI", "HNR1.HA", "HSX.L", "MUV2.DE",
             "RSA.L", "TOP.CO")) ->
  marm_estudy2
  
```


```{r plot 2. Market-adjusted-returns model}
# plot results with ggplot---------------------
print(ggplot(securities_returns, aes(x = date, y = mrank_stat)) 
      + geom_line(aes())
      + ylim(-60,+10)
      + theme(legend.position="none")
      + geom_vline(xintercept = 0)
      + geom_hline(yintercept = 0)
      + labs(x = "day", y = "% change"))
```


```{r}
rates_indx <- get_prices_from_tickers("^N100",
                                      start = as.Date("2000-01-01"),
                                      end = as.Date("2002-01-01"),
                                      quote = "Close",
                                      retclass = "zoo") %>%
    get_rates_from_prices(quote = "Close",
                          multi_day = TRUE,
                          compounding = "continuous")
tickers <- c("ALV.DE", "CS.PA", "G.MI", "HNR1.HA", "HSX.L", "MUV2.DE",
             "RSA.L", "TOP.CO")
nine_eleven_nparam <- get_prices_from_tickers(tickers,
                                              start = as.Date("2000-01-01"),
                                              end = as.Date("2002-01-01"),
                                              quote = "Close",
                                              retclass = "zoo") %>%
    get_rates_from_prices(quote = "Close",
                          multi_day = TRUE,
                          compounding = "continuous") %>%
    apply_market_model(regressor = rates_indx,
                       same_regressor_for_all = TRUE,
                       market_model = "sim",
                       estimation_method = "ols",
                       estimation_start = as.Date("2001-03-26"),
                       estimation_end = as.Date("2001-09-10")) %>%
    nonparametric_tests(event_start = as.Date("2001-09-11"),
                        event_end = as.Date("2001-09-28"))

## End(Not run)
## The result of the code above is equivalent to:
data(securities_returns)
nine_eleven_nparam <- nonparametric_tests(list_of_returns = securities_returns,
                                          event_start = as.Date("2001-09-11"),
                                          event_end = as.Date("2001-09-28"))
```


```{r}
# plot results with ggplot---------------------
print(ggplot(nine_eleven_nparam, aes(x = date, y = mrank_stat)) 
      + geom_line(aes())
      + ylim(-60,+10)
      + theme(legend.position="none")
      + geom_vline(xintercept = 0)
      + geom_hline(yintercept = 0)
      + labs(x = "day", y = "% change"))
```

